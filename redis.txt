
Golang redis 操作初体验 安装
我使用的是 https://github.com/go-redis/r…
这个 golang 客户端, 因此安装方式如下:
go get gopkg.in/redis.v4
接着在代码中导入此包即可:
import "gopkg.in/redis.v4" 基本操作 创建客户端
通过 redis.NewClient 函数即可创建一个 redis 客户端, 这个方法接收一个 redis.Options 对象参数, 通过这个参数, 我们可以配置 redis 相关的属性, 例如 redis 服务器地址, 数据库名, 数据库密码等.
下面是一个连接的例子:
// 创建 redis 客户端 
func createClient() *redis.Client { client := redis.NewClient(&redis.Options{ Addr: "localhost:6379", Password: "", DB: 0, }) 
// 通过 cient.Ping() 来检查是否成功连接到了 redis 服务器 
pong, err := client.Ping().Result() fmt.Println(pong, err) return client } 

String 操作
redis 的 String 操作有:
set(key, value)：给数据库中名称为key的string赋予值value 

get(key)：返回数据库中名称为key的string的 value 
getset(key, value)：给名称为key的string赋予上一次的 value 
mget(key1, key2,…, key N)：返回库中多个string的 value 

setnx(key, value)：添加string，名称为key，值为 value 

setex(key, time, value)：向库中添加string，设定过期时间time 

mset(key N, value N)：批量设置多个string的值 
msetnx(key N, value N)：如果所有名称为key 的string都不存在 

incr(key)：名称为key的string增1操作 

incrby(key, integer)：名称为key的string增加integer 

decr(key)：名称为key的string减1操作 

decrby(key, integer)：名称为key的string减少integer 

append(key, value)：名称为key的string的值附加value 

substr(key, start, end)：返回名称为key的string的value的子串
在 go-redis 中, 我们可以直接找到对应的操作方法, 直接上代码:
// String 操作 

func stringOperation(client *redis.Client) { 
// 第三个参数是过期时间, 如果是0, 则表示没有过期时间. 

err := client.Set("name", "xys", 0).Err() 
if err != nil {
 panic(err) 
 } 
 
 val, err := client.Get("name").Result() 
 if err != nil { panic(err) } 
 fmt.Println("name", val) // 这里设置过期时间. 
 err = client.Set("age", "20", 1 * time.Second).Err() 
 if err != nil { panic(err) } 
 client.Incr("age") // 自增 
 client.Incr("age") // 自增 
 client.Decr("age") // 自减 
 val, err = client.Get("age").Result() 
 if err != nil { panic(err) } 
 fmt.Println("age", val) // age 的值为21 
 // 因为 key "age" 的过期时间是一秒钟, 因此当一秒后, 此 key 会自动被删除了. 
 time.Sleep(1 * time.Second)
 val, err = client.Get("age").Result()
 if err != nil { // 因为 key "age" 已经过期了, 因此会有一个 redis: nil 的错误. 
 fmt.Printf("error: %v/n", err) } 
 fmt.Println("age", val) } 
 
 list 操作
redis 的 list 操作有:

rpush(key, value)：在名称为key的list尾添加一个值为value的元素 
lpush(key, value)：在名称为key的list头添加一个值为value的 元素 
llen(key)：返回名称为key的list的长度 
lrange(key, start, end)：返回名称为key的list中start至end之间的元素 
ltrim(key, start, end)：截取名称为key的list 
lindex(key, index)：返回名称为key的list中index位置的元素 
lset(key, index, value)：给名称为key的list中index位置的元素赋值 
lrem(key, count, value)：删除count个key的list中值为value的元素
 lpop(key)：返回并删除名称为key的list中的首元素 
 rpop(key)：返回并删除名称为key的list中的尾元素 
 blpop(key1, key2,… key N, timeout)：lpop命令的block版本。
 brpop(key1, key2,… key N, timeout)：rpop的block版本。 
 rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部
同样地, 在 go-redis 中也可以找到对应的方法, 下面是一个简单的示例:
// list 操作
 func listOperation(client *redis.Client) {
 client.RPush("fruit", "apple") //在名称为 fruit 的list尾添加一个值为value的元素 
 client.LPush("fruit", "banana") //在名称为 fruit 的list头添加一个值为value的 元素 
 length, err := client.LLen("fruit").Result() //返回名称为 fruit 的list的长度
 if err != nil { panic(err) } fmt.Println("length: ", length) // 长度为2 
 value, err := client.LPop("fruit").Result() //返回并删除名称为 fruit 的list中的首元素 
 if err != nil { panic(err) }
 fmt.Println("fruit: ", value)
 value, err = client.RPop("fruit").Result() // 返回并删除名称为 fruit 的list中的尾元素 
 if err != nil { panic(err) } fmt.Println("fruit: ", value) } 
 
 
 set 操作
redis 的 set 操作:
sadd(key, member)：向名称为key的set中添加元素member 
srem(key, member) ：删除名称为key的set中的元素member 
spop(key) ：随机返回并删除名称为key的set中一个元素
 smove(srckey, dstkey, member) ：移到集合元素 
 scard(key) ：返回名称为key的set的基数
 sismember(key, member) ：member是否是名称为key的set的元素 
 sinter(key1, key2,…key N) ：求交集 
 sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合
 sunion(key1, (keys)) ：求并集 
 sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合
 sdiff(key1, (keys)) ：求差集
 sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合 
 smembers(key) ：返回名称为key的set的所有元素
 srandmember(key) ：随机返回名称为key的set的一个元素
接下来是 go-redis 的 set 操作:
// set 操作 
func setOperation(client *redis.Client) { 
client.SAdd("blacklist", "Obama") // 向 blacklist 中添加元素 
client.SAdd("blacklist", "Hillary") // 再次添加 
client.SAdd("blacklist", "the Elder") // 添加新元素 
client.SAdd("whitelist", "the Elder") // 向 whitelist 添加元素 
// 判断元素是否在集合中 
isMember, err := client.SIsMember("blacklist", "Bush").Result()
 if err != nil { panic(err) } 
 fmt.Println("Is Bush in blacklist: ", isMember) // 求交集, 即既在黑名单中, 又在白名单中的元素 
 names, err := client.SInter("blacklist", "whitelist").Result() if err != nil { panic(err) } // 获取到的元素是 "the Elder" 
 fmt.Println("Inter result: ", names) 
 // 获取指定集合的所有元素
 all, err := client.SMembers("blacklist").Result()
 if err != nil { panic(err) } fmt.Println("All member: ", all) } hash 操作 